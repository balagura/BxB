% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{beam_beam}
\alias{beam_beam}
\title{beam_beam}
\usage{
beam_beam(kicked, kickers, sim, quiet = FALSE)
}
\arguments{
\item{kicked}{List with the parameters of the kicked bunch. It can conveniently be 
created with the \code{\link{kicked}} function. See \code{?kicked} for details.}

\item{kickers}{List for the kicker bunches, can be created using the
\code{\link{kickers}} function. See \code{?kickers} for details.}

\item{sim}{List with B*B simulation options. Can be conveniently created with the
\code{\link{sim}} function. See \code{?sim} for details.}

\item{quiet}{controls whether the input and the execution progress will be printed to cout}
}
\value{
Results of the simulation as data.frame with the
fields\preformatted{"ip"         - interaction point, counting from zero
"step"       - scan step number, counting from zero
"correction" - beam-beam/no beam-beam luminosity ratio
"no_bb_analytic_integ"                       - analytic overlap integral
"no_bb_numeric_over_analytic_integ"          - numeric/analytic ratio
"no_bb_numeric_over_analytic_integ_err"      - its error
"no_bb_avr_x_numeric", "no_bb_avr_y_numeric" - numeric shift, all without beam-beam
"avr_x_analytic", "avr_y_analytic"  - analytic center-of-mass shift with beam-beam
"avr_x_numeric", "avr_y_numeric"    - numeric shift}

In addition, depending on the options specified in \code{sim.output},
the program can print out several files in the \code{sim.output_dir}
directory. See \code{\link{?sim}} for details about that and the simulation
in general.
}
\description{
Simulates bunch particles in an accelerator influenced by the
             electromagnetic interaction with another bunch ("beam-beam"
             effect). Reports corrections to the bunches overlap integral.
}
\examples{
# This example with multiple IPs and with round and elliptical single or
# multi-Gaussian bunches is almost equivalent to the simplest single IP,
# single Gaussian round bunch case which was simulated in 2012 using the
# LHC MAD-X code. This is done for easy comparison with this reference case.
# Though sigmas are different, they are all close to 40 um except at the
# last IP where they are about twice larger (80 um). The beam separations there
# are also twice larger. This is compensated by 4 times larger kicked beta
# (6 instead of 1.5 m at other IPs). This is done to illustrate that overall
# this should give the same results. Indeed, at IP (where the derivative
# d beta/dz = 0), the invariant variables are:
#
#   x    /sqrt(beta) =  emittance*cos(pahes) and
#   dx/dz*sqrt(beta) = -emittance*sin(phase).
#
# If one scales x (ie. sigmas and beam separations) as sqrt(beta), the first
# variable will remain invariant. The electric field (proportional to 1/x) and
# the angular kick of dx/dz will scale as 1/sqrt(beta). Then, the kick of the
# second variable dx/dz*sqrt(beta) will scale as sqrt(beta)/sqrt(beta),
# ie. will also remain invariant. Therefore, the dynamics of these two
# variables will remain the same (if the number of particles in the kicker
# bunch is the same).
#
# On the other hand, one accelerator turn with four IPs with identical phase
# advances between them (0.31 in X and 0.32 in Y in our example) are 
# equivalent to four turns in the accelerator with only one IP. The beam-beam
# effects at four IPs should, therefore, also be identical.
#
# Though not used in the example, below the LHC phases/2pi in vdM scans are given
# for reference. They were calculated by Guido Sterbini using MAD-X simulation
# in 2019 and reported at
#
# https://indico.cern.ch/event/836681/contributions/3507678/attachments/1884149/3105236/2019_07_22.pdf
# indico: https://indico.cern.ch/event/836681/
#
#           Qx1       Qy1       Qx2       Qy2
#  IP1   0.000000  0.000000  0.000000  0.000000
#  IP2   8.295954  7.669167  8.272802  7.957720
#  IP5  31.975690 29.648602 31.984398 29.761319
#  IP8  56.064831 51.017069 55.799012 51.715754
#  IP1  64.310000 59.320000 64.310000 59.320000
#
# 
# If the simulated kicked bunch is in beam 1 and the kickers are in beam 2:
#
# kicked.next_phase_over_2pi.x = 8.295954 31.975690 56.064831 64.310000
# kicked.next_phase_over_2pi.y = 7.669167 29.648602 51.017069 59.320000
#
# If the simulated kicked bunch is in beam 1 and the kickers are in beam 2,
# one should take into account that beam2 goes in the opposite direction, ie.
# in the order IP1->8->5->2->1. So, one needs to take (full tune - table column)
# in reverse order,
#  ie. reversed 64.31 - (0, 8.272802, 31.984398, 55.799012)
#  or  reversed 59.32 - (0, 7.957720, 29.761319, 51.715754):
#
# kicked.next_phase_over_2pi.x = 8.510988 32.325602 56.037198 64.310000
# kicked.next_phase_over_2pi.y = 7.604246 29.558681 51.362280 59.320000
#

beam_beam(kicked = kicked(momentum = 3500, Z = 1, ip = 0,
                          beta = list(x=c(rep(1.5,3), 6),
                                      y=c(rep(1.5,3), 6)), 
                          next_phase_over_2pi = list(x=0.31*(1:4),
                                                     y=0.32*(1:4)),
                          exact_phases = FALSE,
                          gaussian = list(x=list(sig=rep(40,2), w=c(0.2, 0.8)),
                                          y=list(sig=c(39.99, 40), w=c(0.3, 0.7)))),
          kickers =  kickers(Z = 1,
                             n_particles = rep(8.5e10, 4),
                             gaussian = list(x=list(list(sig=rep(40, 2), w=c(0.2, 0.8)),
                                                    list(sig=rep(40, 3), w=c(0.3, 0.6, 0.1)),
                                                    list(sig=c(40.002, 40.001, 40.001, 39.998),
                                                         w=c(2, 10, 10, 2)),
                                                    list(sig=80, w=1)),
                                             y=list(list(sig=40, w=0.2),
                                                    list(sig=40, w=0.2),
                                                    list(sig=40, w=0.2),
                                                    list(sig=c(80.001, 79.999), w=rep(1, 2)))),
                             position = list(x=list(10*(0:20), 10*(0:20), 10*(0:20), 10*(0:20)),
                                             y=list(0,0,0,0))),
          sim =  sim(n_points = 5000,
                     n_turns = c(1000, 1000, 0, 5000),
                     kick_model = 'precise',
                     n_sigma_cut = 5,
                     density_and_field_interpolators_n_cells_along_grid_side = c(500, 500),
                     n_random_points_to_check_interpolation = 10000,
                     select_one_turn_out_of = 1000,
                     seed = 123456789,
                     output_dir = "",
                     output = ""))

}
\author{
Vladislav BALAGURA <balagura@cern.ch>
}
