# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name BxB
#'
#' @title B*B, beam-beam simulation for vdM scans at LHC
#'
#' @description "beam_beam" function simulates bunch particles in an
#'              accelerator influenced by the electromagnetic force of
#'              another bunch ("beam-beam" effect). Reports corrections
#'              to the bunches overlap integral. See "?beam_beam" for details.
#'
#' @docType package
#' @name BxB
#' @author Vladislav BALAGURA <balagura@cern.ch>
#'
#' @import Rcpp
#' @useDynLib BxB
NULL

#' @title beam_beam
#'
#' @description Simulates bunch particles in an accelerator influenced by the
#'              electromagnetic interaction with another bunch ("beam-beam"
#'              effect). Reports corrections to the bunches overlap integral.
#'
#' @param kicked List with the parameters of the kicked bunch. It can conveniently be 
#'           created with the \code{\link{kicked}} function. See \code{?kicked} for details.
#'
#' @param kickers List for the kicker bunches, can be created using the
#'           \code{\link{kickers}} function. See \code{?kickers} for details.
#'
#' @param sim List with B*B simulation options. Can be conveniently created with the
#'           \code{\link{sim}} function. See \code{?sim} for details.
#'
#' @param quiet controls whether the input and the execution progress will be printed to cout
#'
#' @return Results of the simulation as data.frame with the
#' fields\preformatted{"ip"         - interaction point, counting from zero
#' "step"       - scan step number, counting from zero
#' "correction" - beam-beam/no beam-beam luminosity ratio
#' "no_bb_analytic_integ"                       - analytic overlap integral
#' "no_bb_numeric_over_analytic_integ"          - numeric/analytic ratio
#' "no_bb_numeric_over_analytic_integ_err"      - its error
#' "no_bb_avr_x_numeric", "no_bb_avr_y_numeric" - numeric shift, all without beam-beam
#' "avr_x_analytic", "avr_y_analytic"  - analytic center-of-mass shift with beam-beam
#' "avr_x_numeric", "avr_y_numeric"    - numeric shift}
#'
#' In addition, depending on the options specified in \code{sim.output},
#' the program can print out several files in the \code{sim.output_dir}
#' directory. See \code{\link{?sim}} for details about that and the simulation
#' in general.
#'
#' @author Vladislav BALAGURA <balagura@cern.ch>
#'
#' @examples
#' # This example with multiple IPs and with round and elliptical single or
#' # multi-Gaussian bunches is almost equivalent to the simplest single IP,
#' # single Gaussian round bunch case which was simulated in 2012 using the
#' # LHC MAD-X code. This is done for easy comparison with this reference case.
#' # Though sigmas are different, they are all close to 40 um except at the
#' # last IP where they are about twice larger (80 um). The beam separations there
#' # are also twice larger. This is compensated by 4 times larger kicked beta
#' # (6 instead of 1.5 m at other IPs). This is done to illustrate that overall
#' # this should give the same results. Indeed, at IP (where the derivative
#' # d beta/dz = 0), the invariant variables are:
#' #
#' #   x    /sqrt(beta) =  emittance*cos(pahes) and
#' #   dx/dz*sqrt(beta) = -emittance*sin(phase).
#' #
#' # If one scales x (ie. sigmas and beam separations) as sqrt(beta), the first
#' # variable will remain invariant. The electric field (proportional to 1/x) and
#' # the angular kick of dx/dz will scale as 1/sqrt(beta). Then, the kick of the
#' # second variable dx/dz*sqrt(beta) will scale as sqrt(beta)/sqrt(beta),
#' # ie. will also remain invariant. Therefore, the dynamics of these two
#' # variables will remain the same (if the number of particles in the kicker
#' # bunch is the same).
#' #
#' # On the other hand, one accelerator turn with four IPs with identical phase
#' # advances between them (0.31 in X and 0.32 in Y in our example) are 
#' # equivalent to four turns in the accelerator with only one IP. The beam-beam
#' # effects at four IPs should, therefore, also be identical.
#' #
#' # Though not used in the example, below the LHC phases/2pi in vdM scans are given
#' # for reference. They were calculated by Guido Sterbini using MAD-X simulation
#' # in 2019 and reported at
#' #
#' # https://indico.cern.ch/event/836681/contributions/3507678/attachments/1884149/3105236/2019_07_22.pdf
#' # indico: https://indico.cern.ch/event/836681/
#' #
#' #           Qx1       Qy1       Qx2       Qy2
#' #  IP1   0.000000  0.000000  0.000000  0.000000
#' #  IP2   8.295954  7.669167  8.272802  7.957720
#' #  IP5  31.975690 29.648602 31.984398 29.761319
#' #  IP8  56.064831 51.017069 55.799012 51.715754
#' #  IP1  64.310000 59.320000 64.310000 59.320000
#' #
#' # 
#' # If the simulated kicked bunch is in beam 1 and the kickers are in beam 2:
#' #
#' # kicked.next_phase_over_2pi.x = 8.295954 31.975690 56.064831 64.310000
#' # kicked.next_phase_over_2pi.y = 7.669167 29.648602 51.017069 59.320000
#' #
#' # If the simulated kicked bunch is in beam 1 and the kickers are in beam 2,
#' # one should take into account that beam2 goes in the opposite direction, ie.
#' # in the order IP1->8->5->2->1. So, one needs to take (full tune - table column)
#' # in reverse order,
#' #  ie. reversed 64.31 - (0, 8.272802, 31.984398, 55.799012)
#' #  or  reversed 59.32 - (0, 7.957720, 29.761319, 51.715754):
#' #
#' # kicked.x.next.phase.over.2pi = 8.510988 32.325602 56.037198 64.310000
#' # kicked.y.next.phase.over.2pi = 7.604246 29.558681 51.362280 59.320000
#' #
#'
#' beam_beam(kicked = kicked(momentum = 3500, Z = 1, ip = 1,
#'                           beta = list(x=c(rep(1.5,3), 6),
#'                                       y=c(rep(1.5,3), 6)), 
#'                           next_phase_over_2pi = list(x=0.31*(1:4),
#'                                                      y=0.32*(1:4)),
#'                           gaussian = list(x=list(sig=rep(40,2), w=c(0.2, 0.8)),
#'                                           y=list(sig=c(39.99, 40), w=c(0.3, 0.7))),
#'                           exact_phases = FALSE),
#'           kickers =  kickers(Z = 1,
#'                              n_particles = rep(8.5e10, 4),
#'                              gaussian = list(x=list(list(sig=rep(40, 2), w=c(0.2, 0.8)),
#'                                                     list(sig=rep(40, 3), w=c(0.3, 0.6, 0.1)),
#'                                                     list(sig=c(40.002, 40.001, 40.001, 39.998),
#'                                                          w=c(2, 10, 10, 2)),
#'                                                     list(sig=80, w=1)),
#'                                              y=list(list(sig=40, w=0.2),
#'                                                     list(sig=40, w=0.2),
#'                                                     list(sig=40, w=0.2),
#'                                                     list(sig=c(80.001, 79.999), w=rep(1, 2)))),
#'                              position = list(x=list(10*(0:20), 10*(0:20), 10*(0:20), 10*(0:20)),
#'                                              y=list(0,0,0,0))),
#'           sim =  sim(n_points = 5000,
#'                      ns = c(1000, 1000, 0, 5000),
#'                      kick_model = 'precise',
#'                      n_sigma_cut = 5,
#'                      density_and_field_interpolators_n_cells_along_grid_side = c(500, 500),
#'                      n_random_points_to_check_interpolation = 10000,
#'                      select_one_turn_out_of = 1000,
#'                      seed = 123456789,
#'                      output_dir = "",
#'                      output = "")
#'
#' @export
beam_beam <- function(kicked, kickers, sim, quiet = FALSE) {
    .Call('_BxB_beam_beam', PACKAGE = 'BxB', kicked, kickers, sim, quiet)
}

